{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\nvar _react = _interopRequireDefault(require(\"react\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/) /*: number*/\n{\n  var max = 0,\n    bottomY;\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\nfunction cloneLayout(layout\n/*: Layout*/) /*: Layout*/\n{\n  var newLayout = Array(layout.length);\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\nfunction modifyLayout(layout\n/*: Layout*/, layoutItem\n/*: LayoutItem*/) /*: Layout*/\n{\n  var newLayout = Array(layout.length);\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\nfunction withLayoutItem(layout\n/*: Layout*/, itemKey\n/*: string*/, cb\n/*: LayoutItem => LayoutItem*/) /*: [Layout, ?LayoutItem]*/\n{\n  var item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/) /*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\nfunction childrenEqual(a\n/*: ReactChildren*/, b\n/*: ReactChildren*/) /*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/ = require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\nfunction fastPositionEqual(a\n/*: Position*/, b\n/*: Position*/) /*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\nfunction collides(l1\n/*: LayoutItem*/, l2\n/*: LayoutItem*/) /*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\nfunction compact(layout\n/*: Layout*/, compactType\n/*: CompactType*/, cols\n/*: number*/) /*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n  return out;\n}\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/, item\n/*: LayoutItem*/, moveToCoord\n/*: number*/, axis\n/*: \"x\" | \"y\"*/) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\nfunction compactItem(compareWith\n/*: Layout*/, l\n/*: LayoutItem*/, compactType\n/*: CompactType*/, cols\n/*: number*/, fullLayout\n/*: Layout*/) /*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n  var collides;\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  } // Ensure that there are no negative positions\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\nfunction correctBounds(layout\n/*: Layout*/, bounds\n/*: { cols: number }*/) /*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\nfunction getLayoutItem(layout\n/*: Layout*/, id\n/*: string*/) /*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\nfunction getFirstCollision(layout\n/*: Layout*/, layoutItem\n/*: LayoutItem*/) /*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nfunction getAllCollisions(layout\n/*: Layout*/, layoutItem\n/*: LayoutItem*/) /*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\nfunction getStatics(layout\n/*: Layout*/) /*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\nfunction moveElement(layout\n/*: Layout*/, l\n/*: LayoutItem*/, x\n/*: ?number*/, y\n/*: ?number*/, isUserAction\n/*: ?boolean*/, preventCollision\n/*: ?boolean*/, compactType\n/*: CompactType*/, cols\n/*: number*/, allowOverlap\n/*: ?boolean*/) /*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n  var hasCollisions = collisions.length > 0; // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  } // Move each item that collides away from this element.\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/, collidesWith\n/*: LayoutItem*/, itemToMove\n/*: LayoutItem*/, isUserAction\n/*: ?boolean*/, compactType\n/*: CompactType*/, cols\n/*: number*/) /*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/ = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\nfunction perc(num\n/*: number*/) /*: string*/\n{\n  return num * 100 + \"%\";\n}\nfunction setTransform(_ref) /*: Object*/\n{\n  var top = _ref.top,\n    left = _ref.left,\n    width = _ref.width,\n    height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\nfunction setTopLeft(_ref2) /*: Object*/\n{\n  var top = _ref2.top,\n    left = _ref2.left,\n    width = _ref2.width,\n    height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\nfunction sortLayoutItems(layout\n/*: Layout*/, compactType\n/*: CompactType*/) /*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/) /*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/) /*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/, children\n/*: ReactChildren*/, cols\n/*: number*/, compactType\n/*: CompactType*/, allowOverlap\n/*: ?boolean*/) /*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/ = [];\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/) {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return; // Don't overwrite if it already exists.\n\n    var exists = getLayoutItem(initialLayout, String(child.key));\n    if (exists) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n        layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n          i: child.key\n        })));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  }); // Correct the layout.\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\nfunction validateLayout(layout\n/*: Layout*/) /*: void*/\n{\n  var contextName\n  /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n} // Legacy support for verticalCompact: false\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/) /*: CompactType*/\n{\n  var _ref3 = props || {},\n    verticalCompact = _ref3.verticalCompact,\n    compactType = _ref3.compactType;\n  return verticalCompact === false ? null : compactType;\n}\nfunction log() {\n  var _console;\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\nvar noop = function noop() {};\nexports.noop = noop;","map":{"version":3,"names":["Object","defineProperty","exports","value","bottom","childrenEqual","cloneLayout","cloneLayoutItem","collides","compact","compactItem","compactType","correctBounds","fastPositionEqual","fastRGLPropsEqual","getAllCollisions","getFirstCollision","getLayoutItem","getStatics","modifyLayout","moveElement","moveElementAwayFromCollision","noop","perc","setTopLeft","setTransform","sortLayoutItems","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","synchronizeLayoutWithChildren","validateLayout","withLayoutItem","_lodash","_interopRequireDefault","require","_react","obj","__esModule","default","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","isProduction","process","env","NODE_ENV","DEBUG","layout","max","bottomY","len","y","h","newLayout","Array","layoutItem","itemKey","cb","item","w","x","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","resizeHandles","isBounded","a","b","Children","map","c","left","top","width","height","l1","l2","cols","compareWith","sorted","out","l","indexOf","heightWidth","resolveCompactionCollision","moveToCoord","axis","sizeProp","itemIndex","otherItem","fullLayout","compactV","compactH","Math","min","bounds","collidesWith","id","isUserAction","preventCollision","allowOverlap","log","concat","String","oldX","oldY","movingUp","reverse","collisions","hasCollisions","collision","itemToMove","fakeItem","undefined","num","_ref","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","_ref2","slice","sort","initialLayout","children","child","exists","props","_grid","console","warn","g","correctedLayout","contextName","subProps","isArray","Error","j","_ref3","verticalCompact","_console"],"sources":["/root/Electra-Blockathon/electra-fe/node_modules/react-grid-layout/build/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\n\nfunction modifyLayout(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\n\nfunction withLayoutItem(layout\n/*: Layout*/\n, itemKey\n/*: string*/\n, cb\n/*: LayoutItem => LayoutItem*/\n)\n/*: [Layout, ?LayoutItem]*/\n{\n  var item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n)\n/*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n)\n/*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  } // Ensure that there are no negative positions\n\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n  var hasCollisions = collisions.length > 0; // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref)\n/*: Object*/\n{\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2)\n/*: Object*/\n{\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/\n  ) {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return; // Don't overwrite if it already exists.\n\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n\n        layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n          i: child.key\n        })));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  }); // Correct the layout.\n\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  var contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  var _ref3 = props || {},\n      verticalCompact = _ref3.verticalCompact,\n      compactType = _ref3.compactType;\n\n  return verticalCompact === false ? null : compactType;\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = function noop() {};\n\nexports.noop = noop;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}